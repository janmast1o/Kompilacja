#!/usr/bin/python
from collections import defaultdict
import AST
from SymbolTable import SymbolTable, Symbol, VariableSymbol

dict_of_types = defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: "")))

dict_of_types["+"]["int"]["int"] = "int"
dict_of_types["+"]["int"]["float"] = "float"
dict_of_types["+"]["float"]["int"] = "float"
dict_of_types["+"]["float"]["float"] = "float"
dict_of_types["+"]["str"]["str"] = "str"
dict_of_types["+"]["vector"]["vector"] = "vector"
dict_of_types["+"]["matrix"]["matrix"] = "matrix"

dict_of_types["-"]["int"]["int"] = "int"
dict_of_types["-"]["int"]["float"] = "float"
dict_of_types["-"]["float"]["int"] = "float"
dict_of_types["-"]["float"]["float"] = "float"
dict_of_types["-"]["str"]["str"] = "str"
dict_of_types["-"]["vector"]["vector"] = "vector"
dict_of_types["-"]["matrix"]["matrix"] = "matrix"

dict_of_types["*"]["int"]["int"] = "int"
dict_of_types["*"]["int"]["float"] = "float"
dict_of_types["*"]["float"]["int"] = "float"
dict_of_types["*"]["float"]["float"] = "float"
dict_of_types["*"]["str"]["str"] = "str"
dict_of_types["*"]["str"]["int"] = "str"
dict_of_types["*"]["int"]["str"] = "str"
# dict_of_types["*"]["vector"]["vector"] = "vector"
dict_of_types["*"]["matrix"]["matrix"] = "matrix"

dict_of_types["/"]["int"]["int"] = "int"
dict_of_types["/"]["int"]["float"] = "float"
dict_of_types["/"]["float"]["int"] = "float"
dict_of_types["/"]["float"]["float"] = "float"
# dict_of_types["/"]["vector"]["vector"] = "vector"


dict_of_types[">"]["int"]["int"] = "bool"
dict_of_types[">"]["int"]["float"] = "bool"
dict_of_types[">"]["float"]["int"] = "bool"
dict_of_types[">"]["float"]["float"] = "bool"

dict_of_types["<"]["int"]["int"] = "bool"
dict_of_types["<"]["int"]["float"] = "bool"
dict_of_types["<"]["float"]["int"] = "bool"
dict_of_types["<"]["float"]["float"] = "bool"

dict_of_types[">="]["int"]["int"] = "bool"
dict_of_types[">="]["int"]["float"] = "bool"
dict_of_types[">="]["float"]["int"] = "bool"
dict_of_types[">="]["float"]["float"] = "bool"

dict_of_types["<="]["int"]["int"] = "bool"
dict_of_types["<="]["int"]["float"] = "bool"
dict_of_types["<="]["float"]["int"] = "bool"
dict_of_types["<="]["float"]["float"] = "bool"

dict_of_types["=="]["int"]["int"] = "bool"
dict_of_types["=="]["int"]["float"] = "bool"
dict_of_types["=="]["float"]["int"] = "bool"
dict_of_types["=="]["float"]["float"] = "bool"

dict_of_types["!="]["int"]["int"] = "bool"
dict_of_types["!="]["int"]["float"] = "bool"
dict_of_types["!="]["float"]["int"] = "bool"
dict_of_types["!="]["float"]["float"] = "bool"

dict_of_types[".+"]["vector"]["vector"] = "vector"
dict_of_types[".-"]["vector"]["vector"] = "vector"
dict_of_types[".*"]["vector"]["vector"] = "vector"
dict_of_types["./"]["vector"]["vector"] = "vector"
dict_of_types[".+"]["matrix"]["matrix"] = "matrix"
dict_of_types[".-"]["matrix"]["matrix"] = "matrix"
dict_of_types[".*"]["matrix"]["matrix"] = "matrix"
dict_of_types["./"]["matrix"]["matrix"] = "matrix"

dict_of_types["+="]["int"]["int"] = "int"
dict_of_types["+="]["int"]["float"] = "float"
dict_of_types["+="]["float"]["int"] = "float"
dict_of_types["+="]["float"]["float"] = "float"
dict_of_types["+="]["str"]["str"] = "str"
# dict_of_types["+="]["vector"]["vector"] = "vector"
# dict_of_types["+="]["matrix"]["matrix"] = "matrix"

dict_of_types["-="]["int"]["int"] = "int"
dict_of_types["-="]["int"]["float"] = "float"
dict_of_types["-="]["float"]["int"] = "float"
dict_of_types["-="]["float"]["float"] = "float"
dict_of_types["-="]["str"]["str"] = "str"
# dict_of_types["-="]["vector"]["vector"] = "vector"
# dict_of_types["-="]["matrix"]["matrix"] = "matrix"

dict_of_types["*="]["int"]["int"] = "int"
dict_of_types["*="]["int"]["float"] = "float"
dict_of_types["*="]["float"]["int"] = "float"
dict_of_types["*="]["float"]["float"] = "float"
dict_of_types["*="]["str"]["str"] = "str"
# dict_of_types["*="]["vector"]["vector"] = "vector"
# dict_of_types["*="]["matrix"]["matrix"] = "matrix"

dict_of_types["/="]["int"]["int"] = "int"
dict_of_types["/="]["int"]["float"] = "float"
dict_of_types["/="]["float"]["int"] = "float"
dict_of_types["/="]["float"]["float"] = "float"
# dict_of_types["/="]["vector"]["vector"] = "vector"
# dict_of_types["/="]["matrix"]["matrix"] = "matrix"


type_negotiation_dict = defaultdict(lambda: defaultdict(lambda: ""))

type_negotiation_dict["any"]["int"] = "int"
type_negotiation_dict["any"]["float"] = "float"
type_negotiation_dict["any"]["bool"] = "bool"
type_negotiation_dict["any"]["str"] = "str"

type_negotiation_dict["int"]["int"] = "int"
type_negotiation_dict["int"]["float"] = "int"
type_negotiation_dict["int"]["bool"] = "int"

type_negotiation_dict["float"]["float"] = "float"
type_negotiation_dict["float"]["int"] = "float"
type_negotiation_dict["float"]["bool"] = "float"

type_negotiation_dict["bool"]["int"] = "int"
type_negotiation_dict["bool"]["bool"] = "bool"
type_negotiation_dict["bool"]["float"] = "float"

type_negotiation_dict["str"]["str"] = "str"


def negotiate_type(current_type, type_of_new_elem):
    return type_negotiation_dict[current_type][type_of_new_elem]


class NodeVisitor(object):

    def visit(self, node):
        method = 'visit_' + node.__class__.__name__
        visitor = getattr(self, method, self.generic_visit)
        return visitor(node)


    def generic_visit(self, node):        # Called if no explicit visitor function exists for a node.
        if isinstance(node, list):
            for elem in node:
                self.visit(elem)
        else:
            for child in node.children:
                if isinstance(child, list):
                    for item in child:
                        if isinstance(item, AST.Node):
                            self.visit(item)
                elif isinstance(child, AST.Node):
                    self.visit(child)

    # simpler version of generic_visit, not so general
    #def generic_visit(self, node):
    #    for child in node.children:
    #        self.visit(child)



class TypeChecker(NodeVisitor):
    def __init__(self):
        self.current_symbol_table = SymbolTable()

    def read_vector_length(self, vector_node):
        if self.visit(vector_node) != "vector":
            raise Exception("Implementation error !")

        if isinstance(vector_node, AST.VectorNode):
            return len(vector_node.values)
        elif isinstance(vector_node, AST.IDNode):
            symbol = self.current_symbol_table.get(vector_node.value)
            if symbol is None:
                raise Exception("Implementation error 1")
            else:
                return symbol.additional.size[0]


    def read_vector_stored_type(self, vector_node):
        if self.visit(vector_node) != "vector":
            raise Exception("Implementation error 2")

        if isinstance(vector_node, AST.VectorNode):
            negotiated_type = "any"
            for elem in vector_node.values:
                negotiated_type = negotiate_type(negotiated_type, elem)
                if negotiated_type == "":
                    raise Exception("Array stores elements between which there is no implicit type conversion")
            return negotiated_type
        elif isinstance(vector_node, AST.IDNode):
            symbol = self.current_symbol_table.get(vector_node.value)
            if symbol is None:
                raise Exception("Implementation error 3")
            else:
                return symbol.additional.stored_type


    def read_matrix_size(self, matrix_node):
        if self.visit(matrix_node) != "matrix":
            raise Exception("Implementation error 4")

        if isinstance(matrix_node, AST.MatrixNode):
            w = self.read_vector_length(matrix_node.vectors[0])
            h = self.read_vector_length(matrix_node.vectors[1])
            return w, h
        elif isinstance(matrix_node, AST.IDNode):
            symbol = self.current_symbol_table.get(matrix_node.value)
            if symbol is None:
                raise Exception("Implementation error 5")
            else:
                return symbol.additional.size


    def read_matrix_stored_type(self, matrix_node):
        if self.visit(matrix_node) != "matrix":
            raise Exception("Implementation error 6")

        if isinstance(matrix_node, AST.MatrixNode):
            negotiated_type = "any"
            for vector in matrix_node.vectors:
                negotiated_type = negotiate_type(negotiated_type, self.read_vector_stored_type(vector))
                if negotiated_type == "":
                    raise Exception("Matrix stores elements between which there is no implicit type conversion")

            return negotiated_type
        elif isinstance(matrix_node, AST.IDNode):
            symbol = self.current_symbol_table.get(matrix_node.value)
            if symbol is None:
                raise Exception("Implementation error 5")
            else:
                return symbol.additional.stored_type



    def visit_InstructionsNode(self, node):
        for instruction in node.instructions:
            self.visit(instruction)


    def visit_returnInstruction(self, node): # ???
        ...

    def visit_PrintableNode(self, node):
        ...

    def visit_ListOfPrintablesNode(self, node):
        ...

    def visit_Error(self, node):
        ...

    def visit_BinExpr(self, node):
        # alternative usage,
        # requires definition of accept method in class Node
        # type1 = node.left.accept(self)
        # type2 = node.right.accept(self)
        type1 = self.visit(node.left)
        type2 = self.visit(node.right)
        op = node.op
        result_type = dict[op][type1][type2]
        if result_type == "":
            raise Exception(f"Cannot apply operator {op} to types {type1}, {type2}")

        if type1 == "vector":
           length1 = self.read_vector_length(node.left)
           length2 = self.read_vector_length(node.right)
           if length1 != length2:
               raise Exception(f"Attempting to apply operator {op} on vectors of "
                               f"incompatible sizes: {length1} and {length2}")

           stored_type1 = self.read_vector_stored_type(node.left)
           stored_type2 = self.read_vector_stored_type(node.right)
           result_type = dict[op][stored_type1][stored_type2]
           if result_type == "":
               raise Exception(f"Attempting to apply operator {op} on vectors storing "
                               f"incompatible types: {stored_type1} and {stored_type2}")

        elif type1 == "matrix":
            w1, h1 = self.read_matrix_size(node.left)
            w2, h2 = self.read_matrix_size(node.right)
            if w1 != w2 or h1 != h2:
                raise Exception(f"Attempting to apply operator {op} on matrixes of "
                                f"incompatible sizes: {w1},{h1} and {w2},{h2}")

            stored_type1 = self.read_matrix_stored_type(node.left)
            stored_type2 = self.read_matrix_stored_type(node.right)
            result_type = dict[op][stored_type1][stored_type2]
            if result_type == "":
                raise Exception(f"Attempting to apply operator {op} on vectors storing "
                                f"incompatible types: {stored_type1} and {stored_type2}")

        return result_type


    def visit_AssignInstruction(self, node: AST.AssignInstruction):
        v = node.left
        r = node.right
        r_type = self.visit(r)
        op = node.operator

        if op == "=":
            if isinstance(v, AST.IDNode):
                if r_type == "vector":
                    ...
                elif r_type == "matrix":
                    ...





    def visit_ExprNode(self, node):
        return self.visit(node.expr)

    def visit_RelationExpression(self, node):
        type1 = self.visit(node.left)
        type2 = self.visit(node.right)
        op = node.op
        result_type = dict[op][type1][type2]
        if result_type == "":
            raise Exception(f"Cannot apply operator {op} to types {type1}, {type2}")

        return result_type


    def visit_WhileNode(self, node):
        condition_type = self.visit(node.condition)
        if condition_type != "bool":
            raise Exception(f"There must be a bool expression in while condition, not {condition_type}")

        self.current_symbol_table = self.current_symbol_table.pushScope("loop body")
        self.visit(node.body)


    def visit_ForNode(self, node):
        start_type = self.visit(node.start)
        end_type = self.visit(node.end)
        if start_type != "int":
            raise Exception(f"Start in for loop condition must be of type int, not: {start_type}")
        elif end_type != "int":
            raise Exception(f"End in for loop condition must be of type int, not: {start_type}")

        self.current_symbol_table = self.current_symbol_table.pushScope("loop body")
        self.current_symbol_table.put(node.variable, VariableSymbol(node.variable, "int"))
        self.visit(node.body)


    def visit_BreakInstruction(self, node):
        if not self.current_symbol_table.st_name == "loop body":
            raise Exception("Cannot run break outside of loop")
        self.current_symbol_table = self.current_symbol_table.popScope()


    def visit_ContinueInstruction(self, node):
        if not self.current_symbol_table.st_name == "loop body":
            raise Exception("Cannot run break outside of loop")


    def visit_IfElseNode(self, node):
        condition_type = self.visit(node.condition)
        if not condition_type == "bool":
            raise Exception(f"There must be a bool expression in the if condition, not {condition_type}")

        self.current_symbol_table = self.current_symbol_table.pushScope("if body")
        self.visit(node.if_body)
        self.current_symbol_table = self.current_symbol_table.popScope()

        self.current_symbol_table = self.current_symbol_table.pushScope("else body")
        self.visit(node.else_body)
        self.current_symbol_table = self.current_symbol_table.pop()


    def visit_IntNum(self, node):
        return "int"


    def visit_FloatNum(self, node):
        return "float"


    def visit_String(self, node):
        return "str"


    def visit_IDNode(self, node):
        symbol = self.current_symbol_table.get(node.value)
        if symbol is None:
            raise Exception(f"Cannot resolve reference to: {node.name}")

        return symbol.symbol_type


    def visit_Variable(self, node):
        variable_name = node.name
        variable_type = self.visit(variable_name)
        if not variable_type == "vector":
            raise Exception(f"Type {variable_type} is not subscriptable")

        variable_symbol = self.current_symbol_table.get(variable_name)
        if variable_symbol is None or variable_symbol.additional is None:
            raise Exception(f"Implementation error :(")
        else:
            for i in range (0,len(variable_symbol.additional.size)):
                dim_size = variable_symbol.additional.size[i]
                if node.index[i] < 0 or node.index >= dim_size:
                    raise Exception(f"Breached array bounds, "
                                    f"cannot get element at index {node.index[i]}"
                                    f"along dimension {i}, index must "
                                    f"be between {0} and {dim_size-1}")

                return variable_symbol.additional.stored_type


    def visit_MatrixFuncNode(self, node):
        arg_type = self.visit(node.arg)
        if arg_type != "int":
            raise Exception(f"Function {node.func_name} takes one argument of type int, not {arg_type}")

        if isinstance(node.arg, AST.IntNum):
            i = node.arg.value
            if i <= 0:
                raise Exception(f"Function {node.func_name} takes a positive integer"
                                f" as an argument, and so {i} is invalid")


    def visit_ZerosNode(self, node):
        self.visit_MatrixFuncNode(node)


    def visit_EyeNode(self, node):
        self.visit_MatrixFuncNode(node)


    def visit_OnesNode(self, node):
        self.visit_MatrixFuncNode(node)


    def visit_UnaryMinusNode(self, node):
        type1 = self.visit(node.expr)
        if type1 != "int" and type1 != "float" and type1 != "bool":
            raise Exception(f"Unary minus can only be applied to int, float and bool, not {type1}")

        return type1


    def visit_TransposeNode(self, node):
        type1 = self.visit(node.expr)
        if type1 != "matrix":
            raise Exception("Can only transpose a matrix")
        elif isinstance(node.expr, AST.IDNode):
            name = node.expr.value
            expr_symbol = self.current_symbol_table.get(name)
            if expr_symbol is None:
                raise Exception("Variable uninitialized")
            elif expr_symbol.additional is None:
                raise Exception("implementation error :(")

            return expr_symbol.additional.stored_type








